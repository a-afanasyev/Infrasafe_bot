services:
  # =============================================================================
  # CORE MICROSERVICES
  # =============================================================================

  # Auth Service - JWT, Sessions, RBAC
  auth-service:
    build:
      context: ./auth_service
      dockerfile: Dockerfile
    container_name: auth-service
    ports:
      - "${AUTH_SERVICE_PORT:-8001}:8001"
    environment:
      - DATABASE_URL=postgresql+asyncpg://${AUTH_DB_USER:-auth_user}:${AUTH_DB_PASSWORD:-auth_pass}@auth-db:5432/${AUTH_DB_NAME:-auth_db}
      - REDIS_URL=redis://${REDIS_HOST:-shared-redis}:${REDIS_PORT:-6379}/${REDIS_AUTH_DB:-1}
      - USER_SERVICE_URL=http://user-service:${USER_SERVICE_PORT:-8002}
      - DEBUG=${DEBUG:-true}
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
    depends_on:
      auth-db:
        condition: service_healthy
      shared-redis:
        condition: service_healthy
    volumes:
      - ./auth_service/logs:/app/logs
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # User Service - Users, Profiles, Verification
  user-service:
    build:
      context: ./user_service
      dockerfile: Dockerfile
    container_name: user-service
    ports:
      - "${USER_SERVICE_PORT:-8002}:8002"
    environment:
      - USER_DATABASE_URL=postgresql+asyncpg://${USER_DB_USER:-user_user}:${USER_DB_PASSWORD:-user_pass}@user-db:5432/${USER_DB_NAME:-user_db}
      - USER_AUTH_SERVICE_URL=http://auth-service:${AUTH_SERVICE_PORT:-8001}
      - USER_MEDIA_SERVICE_URL=http://media-service:${MEDIA_SERVICE_PORT:-8004}
      - USER_NOTIFICATION_SERVICE_URL=http://notification-service:${NOTIFICATION_SERVICE_PORT:-8005}
      - USER_REDIS_URL=redis://${REDIS_HOST:-shared-redis}:${REDIS_PORT:-6379}/${REDIS_USER_DB:-2}
      - USER_DEBUG=${DEBUG:-true}
      - USER_LOG_LEVEL=${LOG_LEVEL:-INFO}
    depends_on:
      user-db:
        condition: service_healthy
      auth-service:
        condition: service_healthy
    volumes:
      - ./user_service/logs:/app/logs
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8002/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Request Service - Requests, Comments, Ratings
  request-service:
    build:
      context: ./request_service
      dockerfile: Dockerfile
    container_name: request-service
    ports:
      - "${REQUEST_SERVICE_PORT:-8003}:8003"
    environment:
      - DATABASE_URL=postgresql+asyncpg://${REQUEST_DB_USER:-request_user}:${REQUEST_DB_PASSWORD:-request_pass}@request-db:5432/${REQUEST_DB_NAME:-request_db}
      - REDIS_URL=redis://${REDIS_HOST:-shared-redis}:${REDIS_PORT:-6379}/${REDIS_REQUEST_DB:-3}
      - AUTH_SERVICE_URL=http://auth-service:${AUTH_SERVICE_PORT:-8001}
      - USER_SERVICE_URL=http://user-service:${USER_SERVICE_PORT:-8002}
      - MEDIA_SERVICE_URL=http://media-service:${MEDIA_SERVICE_PORT:-8004}
      - NOTIFICATION_SERVICE_URL=http://notification-service:${NOTIFICATION_SERVICE_PORT:-8005}
      - DEBUG=${DEBUG:-true}
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
    depends_on:
      request-db:
        condition: service_healthy
      shared-redis:
        condition: service_healthy
      auth-service:
        condition: service_healthy
    volumes:
      - ./request_service/logs:/app/logs
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8003/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Media Service - File uploads, streaming
  media-service:
    build:
      context: ./media_service
      dockerfile: Dockerfile
    container_name: media-service
    ports:
      - "${MEDIA_SERVICE_PORT:-8004}:8004"
    environment:
      - DATABASE_URL=postgresql+asyncpg://${MEDIA_DB_USER:-media_user}:${MEDIA_DB_PASSWORD:-media_pass}@media-db:5432/${MEDIA_DB_NAME:-media_db}
      - REDIS_URL=redis://${REDIS_HOST:-shared-redis}:${REDIS_PORT:-6379}/${REDIS_MEDIA_DB:-4}
      - STORAGE_PATH=${MEDIA_STORAGE_PATH:-/app/storage}
      - MAX_FILE_SIZE=${MAX_FILE_SIZE:-52428800}
      - TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
      - DEBUG=${DEBUG:-true}
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
    depends_on:
      media-db:
        condition: service_healthy
    volumes:
      - ./media_service/storage:/app/storage
      - ./media_service/logs:/app/logs
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8004/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Notification Service - Multi-channel notifications
  notification-service:
    build:
      context: ./notification_service
      dockerfile: Dockerfile
    container_name: notification-service
    ports:
      - "${NOTIFICATION_SERVICE_PORT:-8005}:8005"
    environment:
      - DATABASE_URL=postgresql+asyncpg://${NOTIFICATION_DB_USER:-notification_user}:${NOTIFICATION_DB_PASSWORD:-notification_pass}@notification-db:5432/${NOTIFICATION_DB_NAME:-notification_db}
      - REDIS_URL=redis://${REDIS_HOST:-shared-redis}:${REDIS_PORT:-6379}/${REDIS_NOTIFICATION_DB:-5}
      - TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
      - EMAIL_SMTP_SERVER=${EMAIL_SMTP_SERVER}
      - EMAIL_SMTP_PORT=${EMAIL_SMTP_PORT}
      - EMAIL_USER=${EMAIL_USER}
      - EMAIL_PASSWORD=${EMAIL_PASSWORD}
      - DEBUG=${DEBUG:-true}
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
    depends_on:
      notification-db:
        condition: service_healthy
      shared-redis:
        condition: service_healthy
    volumes:
      - ./notification_service/logs:/app/logs
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8005/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # AI Service - Smart Assignment, ML, Optimization
  ai-service:
    build:
      context: ./ai_service
      dockerfile: Dockerfile
    container_name: ai-service
    ports:
      - "${AI_SERVICE_PORT:-8006}:8006"
    environment:
      # Core configuration
      - AI_SERVICE_NAME=ai-service
      - AI_SERVICE_PORT=8006
      - DEBUG=${DEBUG:-false}

      # Database connections
      - AI_DATABASE_URL=postgresql+asyncpg://${AI_DB_USER:-ai_user}:${AI_DB_PASSWORD:-ai_pass}@ai-db:5432/${AI_DB_NAME:-ai_db}
      - AI_REDIS_URL=redis://${REDIS_HOST:-shared-redis}:${REDIS_PORT:-6379}/${REDIS_AI_DB:-6}

      # Service integration
      - AUTH_SERVICE_URL=http://auth-service:${AUTH_SERVICE_PORT:-8001}
      - USER_SERVICE_URL=http://user-service:${USER_SERVICE_PORT:-8002}
      - REQUEST_SERVICE_URL=http://request-service:${REQUEST_SERVICE_PORT:-8003}

      # AI configuration
      - ML_ENABLED=${AI_ML_ENABLED:-false}
      - GEO_ENABLED=${AI_GEO_ENABLED:-false}
      - MODEL_PATH=/app/models
      - TRAINING_DATA_RETENTION_DAYS=90

      # Performance tuning
      - MAX_CONCURRENT_ASSIGNMENTS=10
      - ASSIGNMENT_TIMEOUT_SECONDS=30
      - CIRCUIT_BREAKER_THRESHOLD=5

      # Monitoring
      - JAEGER_ENDPOINT=http://jaeger:14268/api/traces
      - PROMETHEUS_ENABLED=true

    depends_on:
      ai-db:
        condition: service_healthy
      shared-redis:
        condition: service_healthy
      auth-service:
        condition: service_healthy

    volumes:
      - ./ai_service/models:/app/models
      - ./ai_service/logs:/app/logs

    networks:
      - microservices-network

    restart: unless-stopped

    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8006/api/v1/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # =============================================================================
  # DATABASES
  # =============================================================================

  # Auth Service Database
  auth-db:
    image: postgres:15-alpine
    container_name: auth-db
    environment:
      POSTGRES_USER: ${AUTH_DB_USER:-auth_user}
      POSTGRES_PASSWORD: ${AUTH_DB_PASSWORD:-auth_pass}
      POSTGRES_DB: ${AUTH_DB_NAME:-auth_db}
    ports:
      - "${AUTH_DB_PORT:-5433}:5432"
    volumes:
      - auth_db_data:/var/lib/postgresql/data
      - ./init-scripts/auth:/docker-entrypoint-initdb.d
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U auth_user -d auth_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # User Service Database
  user-db:
    image: postgres:15-alpine
    container_name: user-db
    environment:
      POSTGRES_USER: ${USER_DB_USER:-user_user}
      POSTGRES_PASSWORD: ${USER_DB_PASSWORD:-user_pass}
      POSTGRES_DB: ${USER_DB_NAME:-user_db}
    ports:
      - "${USER_DB_PORT:-5434}:5432"
    volumes:
      - user_db_data:/var/lib/postgresql/data
      - ./init-scripts/users:/docker-entrypoint-initdb.d
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user_user -d user_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Request Service Database
  request-db:
    image: postgres:15-alpine
    container_name: request-db
    environment:
      POSTGRES_USER: ${REQUEST_DB_USER:-request_user}
      POSTGRES_PASSWORD: ${REQUEST_DB_PASSWORD:-request_pass}
      POSTGRES_DB: ${REQUEST_DB_NAME:-request_db}
    ports:
      - "${REQUEST_DB_PORT:-5435}:5432"
    volumes:
      - request_db_data:/var/lib/postgresql/data
      - ./init-scripts/requests:/docker-entrypoint-initdb.d
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U request_user -d request_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Media Service Database
  media-db:
    image: postgres:15-alpine
    container_name: media-db
    environment:
      POSTGRES_USER: ${MEDIA_DB_USER:-media_user}
      POSTGRES_PASSWORD: ${MEDIA_DB_PASSWORD:-media_pass}
      POSTGRES_DB: ${MEDIA_DB_NAME:-media_db}
    ports:
      - "${MEDIA_DB_PORT:-5436}:5432"
    volumes:
      - media_db_data:/var/lib/postgresql/data
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U media_user -d media_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Notification Service Database
  notification-db:
    image: postgres:15-alpine
    container_name: notification-db
    environment:
      POSTGRES_USER: ${NOTIFICATION_DB_USER:-notification_user}
      POSTGRES_PASSWORD: ${NOTIFICATION_DB_PASSWORD:-notification_pass}
      POSTGRES_DB: ${NOTIFICATION_DB_NAME:-notification_db}
    ports:
      - "${NOTIFICATION_DB_PORT:-5437}:5432"
    volumes:
      - notification_db_data:/var/lib/postgresql/data
      - ./init-scripts/notifications:/docker-entrypoint-initdb.d
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U notification_user -d notification_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # AI Service Database
  ai-db:
    image: postgres:15-alpine
    container_name: ai-db
    environment:
      POSTGRES_USER: ${AI_DB_USER:-ai_user}
      POSTGRES_PASSWORD: ${AI_DB_PASSWORD:-ai_pass}
      POSTGRES_DB: ${AI_DB_NAME:-ai_db}
    ports:
      - "${AI_DB_PORT:-5438}:5432"
    volumes:
      - ai_db_data:/var/lib/postgresql/data
      - ./init-scripts/ai:/docker-entrypoint-initdb.d
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ai_user -d ai_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # =============================================================================
  # SHARED INFRASTRUCTURE
  # =============================================================================

  # Shared Redis for all services
  shared-redis:
    image: redis:7-alpine
    container_name: shared-redis
    ports:
      - "6379:6379"
    volumes:
      - shared_redis_data:/data
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      - microservices-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # =============================================================================
  # INFRASTRUCTURE AND MONITORING
  # =============================================================================

  # Traefik Reverse Proxy
  traefik:
    image: traefik:v3.0
    container_name: traefik
    command:
      - --api.insecure=true
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --entrypoints.web.address=:${TRAEFIK_WEB_PORT:-80}
      - --entrypoints.websecure.address=:${TRAEFIK_WEBSECURE_PORT:-443}
      - --certificatesresolvers.myresolver.acme.tlschallenge=true
      - --certificatesresolvers.myresolver.acme.email=${ACME_EMAIL:-admin@uk-management.com}
      - --certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json
    ports:
      - "${TRAEFIK_WEB_PORT:-80}:80"
      - "${TRAEFIK_WEBSECURE_PORT:-443}:443"
      - "${TRAEFIK_DASHBOARD_PORT:-8080}:8080"  # Traefik dashboard
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./traefik/letsencrypt:/letsencrypt
      - ./traefik/dynamic:/etc/traefik/dynamic
    networks:
      - microservices-network
    restart: unless-stopped

  # Prometheus Monitoring
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "${PROMETHEUS_PORT:-9090}:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - ./prometheus/alerts:/etc/prometheus/alerts
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    networks:
      - microservices-network
    restart: unless-stopped

  # Grafana Dashboards
  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "${GRAFANA_PORT:-3000}:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD:-admin123}
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
      - ./grafana/dashboards:/var/lib/grafana/dashboards
    depends_on:
      - prometheus
    networks:
      - microservices-network
    restart: unless-stopped

  # Jaeger Tracing
  jaeger:
    image: jaegertracing/all-in-one:latest
    container_name: jaeger
    ports:
      - "16686:16686"  # Jaeger UI
      - "14268:14268"  # Jaeger collector
    environment:
      - COLLECTOR_ZIPKIN_HOST_PORT=:9411
    networks:
      - microservices-network
    restart: unless-stopped

# =============================================================================
# NETWORKS AND VOLUMES
# =============================================================================

networks:
  microservices-network:
    driver: bridge
    ipam:
      config:
        - subnet: ${NETWORK_SUBNET:-172.20.0.0/16}

volumes:
  # Database volumes
  auth_db_data:
    driver: local
  user_db_data:
    driver: local
  request_db_data:
    driver: local
  media_db_data:
    driver: local
  notification_db_data:
    driver: local
  ai_db_data:
    driver: local

  # Cache volumes
  shared_redis_data:
    driver: local

  # Monitoring volumes
  prometheus_data:
    driver: local
  grafana_data:
    driver: local